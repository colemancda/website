---
date: "2018-05-14"
title: "Introducing xcbuddy"
author: pedro
description: "xxx"
published: false
---

It's been a year since I started working on an Xcode project parser with the goal of implementing a tool that would help large teams scale their Xcode projects. At that time I was doing a lot of research on how modularizing Xcode projects helped overcoming common issues such as compilation times, which **had a very negative impact on developers productivity and motivation.** You can read more about it [here](https://github.com/pepibumur/microfeatures-guidelines).

Modularization turned out to be a good first step, but not enough. Modularizing a codebase results in a lot of workspaces, projects, schemes and targets that we need to maintain, and that has an associated cost. Although Xcode facilitates it a bit by providing things like configuration files to reuse build settings, most of the settings are codified into Xcode projects, that we can **only modify using the API that Apple provides, Xcode.**

With some work, and a lot of lines of code, I'm thrilled to present a tool that I've been working on to support you on using Xcode at scale, [xcbuddy](https://github.com/xcbuddy/xcbuddy). It's one of the largest open source projects I've worked on. It's entirely written in Swift and its core leverages Xcode projects generation to abstract you away from some implicitness and maintenance hassle that developers shouldn't have to worry about.

## Convention over configuration

Like the Swift Package Manager (SPM), which you might already be familiar with, xcbuddy aims convention over configuration. SPM established the definition of what a _"Package"_ is and provided a set of tools for creating package projects and managing dependencies. By following a predefined set of conventions, a tool ensures a more predictable input, which leads to a more reliable tool that can catch misconfigurations early.

xcbuddy took the same approach, and applied it to Xcode projects, regardless of its nature or structure. It allows developers define their projects in type-safe `Project.swift`, known as manifest. As you can see below, the format of those manifests is aligned with the structure of Xcode projects, with a subtle difference, it facilitates reusing project attributes thanks to the Swift language. Let's say for instance, that you'd like to have a function that generates targets with the same naming convention. You could define a function in the manifest `(name: String) -> Target` that you can call to generate your projec targets. The function can be in the `Project.swift` or in another Swift file that you can include, because xcbuddy support Swift modules. By just adding a line at the top with the syntax `swift:include Shared.swift`, your shared Swift code would get compiled together with the maniefst, making all the Swift code in it available from the manifest.

**If your project is modular, you'll realize how useful this simple feature is. You can have single sources of truth for your pojects format, and reuse them from anywhere.**

```swift
import ProjectDescription

let project = Project(name: "HelloWorld",
              schemes: [],
              settings: Settings(base: [:],
                              debug: Configuration(settings: [:],
                                               xcconfig: "Debug.xcconfig")),
              targets: [
                  Target(name: "HelloWorld",
                       platform: .ios,
                       product: .app,
                       bundleId: "com.xcbuddy.HelloWorld",
                       infoPlist: "Info.plist",
                       dependencies: [],
                       settings: nil,
                       buildPhases: [
                        .sources([.include(["./Sources/**/*.swift"])]),
                       ]),
              ])
```

<!--
            <li>üê¶ Type-safe projects definitions editable with Xcode.</li>
            <li>‚ÜóÔ∏è Local dependencies support.</li>
            <li>‚ö†Ô∏è Misconfiguration early catching.</li>
            <li>üì¶ Precompiled binaries support (frameworks and libraries).</li>
            <li>üíª CLI and macOS application.</li>
            <li>üîÑ Circular dependency detection.</li>
            <li>ü•ò 100% open source and written in Swift.</li> -->

## Failing early

One of the advantages of abstracting you away from some Xcode projects implicitness is that we can catch misconfigurations earlier and fail. This will save you a lot of time that you used to spend waiting for the compiler to complain with unclear error messages. Here are some examples that might resonate with you.

* When your watch extension doesn't have a valid bundle id: `com.domain.app.watchkitapp.watchkitextension`.
* If your invalid platform

xcbuddy contains a list of default validations that will continue to grow with the feedback that developers give us about the tool.

## How does it work?

xcbudy was designed with the same principle as the Swift Package Manager. Projects are defined in manifest files that work as an abstraction layer between you, and the combo editor + build system. With xcbuddy, projects are defined in _Project.swift_ manifests that are grouped in a _Workspace.swift_. A _Project.swift_ file has the following structure:

```swift
import ProjectDescription

let project = Project(name: "HelloWorld",
              schemes: [
                  Scheme(name: "HelloWorld",
                         shared: true,
                         buildAction: BuildAction(targets: ["HelloWorld"])),
              ],
              settings: Settings(base: [:],
                              debug: Configuration(settings: [:],
                                               xcconfig: "Debug.xcconfig")),
              targets: [
                  Target(name: "HelloWorld",
                       platform: .ios,
                       product: .app,
                       bundleId: "com.xcbuddy.HelloWorld",
                       infoPlist: "Info.plist",
                       dependencies: [
                        /* Target dependencies can be defined here */
                        /* .framework(path: "/path/framework.framework") */
                       ],
                       settings: nil,
                       buildPhases: [
                        .sources([.include(["./Sources/**/*.swift"])]),
                       ]),
              ])
```

The manifest format is aligned to Xcode projects using the same naming convention and structure that developers are already used to in Xcode.

## Dependencies

One of the core features of xcbuddy is its local dependencies management. You can define:

* Dependencies between targets in the same project.
* Dependencies between targets in different projects.
* Dependencies with precompiled frameworks _(e.g Carthage)_.
* Dependencies with precompiled libraries.

For instance, the connection a tests target and the target which is being tested, is a dependency. When dependencies are specified, xcbuddy does all the necessary setup for you, so you don't have to worry about things like where the framework needs to be embedded, or what flags need to be added to the target build settings. That's great üéâ, isn't it?

> _If a dependency contains architectures that are not necessary for the device we are building the app for, xcbuddy configures the project to strip the unnecessary architectures._

## Start using it

If you would like to give it a try, we made the installation process very easy for you. Just go to your terminal and execute:

```bash
/usr/bin/ruby -e "$(curl -fsSL https://goo.gl/4cbZoL)"
```

That's all you have to do. It'll pull the latest version of xcbuddy, install it in your system, and create a symbolic link to run xcbuddy from any directory in your shell. Right after installing the tool you can create your first project with:

```bash
xcbuddy init --platform ios --type application
xcbuddy generate
```

It'll create all the necessary files in the current directory and generate an Xcode project that you can open with Xcode.

## What's next

First of all, we'd like to collect as much feedback as possible from all of you. We'd love to understand what your needs are, which problems you face, and have a constructive discussion to keep improving the tool. There are a lot of ideas in the backlog around things xcbuddy could help teams with. Unfortunately, the project is starting and we are a few working working on its free time to make it possible. **If the project sounds exciting to you, and you would like to contribute you have are invited to do so.**

If you'd like to get involved, we have a [**Community on Spectrum**](https://spectrum.chat/xcbuddy) that you can join and discuss ideas with other developers using the tool. Moreover, all the GitHub repositories are public so you can also create Issues and PRs in any of the projects.

I can't wait to see how you use xcbuddy and all the ideas that come out of it.

Happy coding! ‚ù§Ô∏èüë©‚Äçüíª
